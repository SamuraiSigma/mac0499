\chapter{Bibliotecas para Reconhecimento de Voz}
\label{cap:speech-libs}

Neste capítulo, veremos o primeiro item necessário para atingirmos o objetivo final: uma biblioteca que fará o reconhecimento de voz dentro do módulo.

Uma implementação do zero fugiria do tema deste trabalho, pois seria necessário aprender sobre reconhecimento de padrões voltado a sons e outros tópicos relacionados a Inteligência Artificial. A outra opção existente, e a que seguiremos, é procurar por uma biblioteca existente e aprender a manejá-la.

Analisaremos quais as características necessárias e desejáveis na biblioteca ideal, e estudaremos a que melhor se adequa ao nosso objetivo dentre as opções existentes.

% ---------------------------------------------------------------------

\section{Considerações iniciais}

Recordemos os principais componentes para reconhecimento de voz, apresentados na seção \ref{sttComponents}. No contexto do módulo de reconhecimento de voz para \textit{Godot}, as seguintes associações surgem naturalmente:

\begin{itemize}
\item O \textbf{usuário} representa tipicamente o \textbf{jogador}, que interage parcialmente ou totalmente com o jogo por meio de comandos de voz.

\item O \textbf{dispositivo de STT} corresponde ao \textbf{módulo de reconhecimento de voz}, objetivo principal deste trabalho. Esta componente é usada pelo jogo para converter a fala do jogador em texto.

\item O \textbf{software de aplicação} é o \textbf{jogo} em si, feito em \textit{Godot}, que recebe indiretamente os comandos do usuário e realiza ações apropriadas.
\end{itemize}

% ---------------------------------------------------------------------

\section{A biblioteca ideal}
\label{idealLibrary}

Realçamos novamente que o módulo de reconhecimento de voz será usado diretamente em jogos. Tal contexto automaticamente nos leva a pensar em diversas características que a biblioteca ideal deve possuir.

% ---------------------------------------------------------------------

\subsection{Características obrigatórias}

Em ordem decrescente de importância, temos:

\begin{enumerate}
\item \textbf{Ter código aberto e licença permissiva:} Justifica-se pela integração da biblioteca em uma \textit{game engine} de código aberto. A importância é ainda maior se levarmos em conta que jogos com fins comerciais podem ser produzidos em \textit{Godot}.

\item \textbf{Ser eficiente (rápida):} Já foi mencionado que o módulo de reconhecimento de voz será usado em uma \textit{game engine}. Um jogo é um \textit{software} onde tipicamente a eficiência é de extrema importância, pois costuma envolver a renderização de cenas várias vezes por segundo. Devido a isso, surge a necessidade da biblioteca ser \emph{rápida} para não afetar negativamente a experiência do jogador.

\item \textbf{Reconhecer inglês:} O inglês possui presença constante em cenários de computação. Portanto, é a única língua que a biblioteca deve obrigatoriamente oferecer suporte.

\item \textbf{Não ser pesada:} Não é desejável ter uma biblioteca que ocupe muito espaço em disco (o que poderia aumentar o tamanho do jogo que a utiliza) e memória (aspecto relacionado diretamente à eficiência).
\end{enumerate}

% ---------------------------------------------------------------------

\subsection{Características desejáveis}

Em ordem decrescente de importância, temos:

\begin{enumerate}
\item \textbf{Ser multiplataforma:} \textit{Godot} possibilita exportar jogos para diferentes plataformas, dentre elas Windows, MacOS, Unix, Android e iOS \citep{godotDeployPlatforms}. Uma biblioteca que possa ser compatível com o maior número possível destes sistemas operacionais tornaria o módulo de reconhecimento de voz mais flexível para a produção de jogos em diferentes ambientes.

\item \textbf{Reconhecer diferentes línguas:} Apesar da obrigatoriedade do inglês, a possibilidade de usar diferentes línguas aumentaria a versatilidade do módulo. Tal característica é acentuada ao notarmos que muitos jogos, hoje em dia, oferecem a possibilidade de alterar a língua.

\item \textbf{Ser implementada em C/C++:} Conforme veremos na seção \ref{cap:godot}, \textit{Godot} possui toda a sua base escrita em C++, linguagem também usada para a criação de módulos. A implementação da biblioteca na mesma linguagem ajudaria a simplificar problemas de compatibilidade. Eventualmente, C também é uma opção viável por ser aceita pela linguagem sucessora.
\end{enumerate}

% ---------------------------------------------------------------------

\section{Bibliotecas viáveis}

Realizou-se uma pesquisa por bibliotecas de reconhecimento de voz que sigam o máximo de características possíveis propostas na seção \ref{idealLibrary}. O artigo \citep{sttLibs} sintetiza razoavelmente bem os resultados da busca. A seguir, destacamos as quatro bibliotecas mais notáveis encontradas:

\begin{itemize}
\item \textbf{Kaldi} \citep{kaldi}: É a biblioteca mais recente da lista, com seu código publicado em 2011. Escrita em C++, é tida como uma biblioteca para pesquisadores de reconhecimento de voz.

\item \textbf{CMUSphinx} \citep{cmusphinx}: Desenvolvida pela \textit{Carnegie Mellon University}, possui diversos pacotes para diferentes tarefas e aplicações. O pacote principal é escrito em Java. Existe também a variante \emph{Pocketsphinx}, com características interessantes para este trabalho: é escrita em C, possuindo maior velocidade e portabilidade que a biblioteca original.

\item \textbf{HTK} \citep{htk}: Desenvolvida pela \textit{Cambridge University Engineering Department}, HTK é uma sigla para \textit{Hidden Markov Model Toolkit}. É escrita em C, com novas versões sendo lançadas consistentemente.

\item \textbf{Simon} \citep{Simon}: Popular para Linux e escrita em C++, Simon utiliza \textit{CMUSphinx}, \textit{HTK} e \textit{Julius} internamente. Não havia suporte para \textit{MacOS} até abril de 2017.
\end{itemize}

% TODO: Explicar melhor a parte abaixo
Um artigo de 2014 comparou \emph{Kaldi}, \emph{CMUSphinx} e \emph{HTK} em relação a precisão e tempo gasto \citep{compareSpeech}. \emph{Kaldi} obteve resultados vastamente superiores; \emph{CMUSphinx} obteve bons resultados em pouco tempo; \emph{HTK} precisou de muito mais tempo e treino para conseguir resultados na ordem dos outros dois.

% ---------------------------------------------------------------------

\section{\emph{Pocketsphinx}}

Nesta seção, analisaremos mais a fundo a biblioteca \textit{Pocketsphinx}, incluindo instruções para usá-la de forma básica e passos para compilação a partir do código fonte.

Supõe-se que o usuário esteja usando um sistema operacional \textit{Unix}, e que possua acesso a privilégios administrativos para a realização de alguns passos. Recomenda-se que o leitor possua um microfone à disposição no computador, podendo ser embutido ou externo, para melhor aproveitamento.

Todas as instruções e comandos apresentados foram realizados no sistema \texttt{Ubuntu 16.04 LTS, 64-bit} do autor.

% ---------------------------------------------------------------------

\subsection{Funcionamento}

% ---------------------------------------------------------------------

\subsection{Compilação}
\label{sphinxCompile}

Apresentamos as instruções, em \textit{Bash}, para baixar o código fonte do \textit{Pocketsphinx} e compilá-lo. Os passos foram baseados nas instruções em \citep{pocketsphinxInstall}.

\begin{enumerate}
\item Instale as seguintes dependências:

\begin{center}
\footnotesize\texttt{gcc, automake, autoconf, libtool, bison, swig, python-dev, pulseaudio}
\end{center}

Em um sistema \emph{Ubuntu}, por exemplo, digitaria-se no terminal:

\begin{lstlisting}[language=Bash]
$ sudo apt-get install gcc automake autoconf libtool bison swig \
  python-dev pulseaudio
\end{lstlisting}

\item Baixe e compile o código do pacote \textbf{Sphinxbase}. Este oferece funcionalidades comuns a todos os pacotes \textit{CMUSphinx}:

\begin{enumerate}
\item Clone o repositório do \textit{Sphinxbase}.

\begin{lstlisting}[language=Bash]
$ git clone https://github.com/cmusphinx/sphinxbase
\end{lstlisting}

\item Dentro do diretório \texttt{sphinxbase} criado pelo passo anterior, execute o \textit{script} \texttt{autogen.sh} para gerar o arquivo \texttt{configure}:

\begin{lstlisting}[language=Bash]
$ ./autogen.sh
\end{lstlisting}

\item Execute o \textit{script} \texttt{configure} criado no último passo:

\begin{lstlisting}[language=Bash]
# Padrão
$ ./configure

# Plataformas sem aritmética de ponto flutuante
$ ./configure ---enable-fixed ---without-lapack
\end{lstlisting}

Note que qualquer dependência ausente no sistema (por exemplo, o pacote \texttt{swig}) será notificada ao usuário neste passo. Se a execução ocorrer sem problemas, um \texttt{Makefile} será gerado.

\item Construa a biblioteca \textit{Sphinxbase} através do \texttt{Makefile}:
\begin{lstlisting}[language=Bash]
$ make
\end{lstlisting}
\end{enumerate}

\item Baixe e compile o código do pacote \textbf{Pocketsphinx} em si.

\begin{enumerate}
\item Clone o repositório do \textit{Pocketsphinx}.

\begin{lstlisting}[language=Bash]
$ git clone https://github.com/cmusphinx/pocketsphinx
\end{lstlisting}

\item Certifique-se que as pastas \texttt{sphinxbase} e \texttt{pocketsphinx} estejam no mesmo diretório, pois \textit{Pocketsphinx} usa o caminho \texttt{../} para procurar pelo pacote \textit{Sphinxbase}.

\item Dentro do diretório \texttt{pocketsphinx}, execute o \textit{script} \texttt{autogen.sh} para gerar o arquivo \texttt{configure}:

\begin{lstlisting}[language=Bash]
$ ./autogen.sh
\end{lstlisting}

\item Execute o \textit{script} \texttt{configure} criado no último passo:

\begin{lstlisting}[language=Bash]
$ ./configure
\end{lstlisting}

Note que qualquer dependência ausente no sistema será notificada ao usuário neste passo. Se a execução ocorrer sem problemas, um \texttt{Makefile} será gerado.

\item Construa a biblioteca através do \texttt{Makefile}:

\begin{lstlisting}
$ make
\end{lstlisting}
\end{enumerate}
\end{enumerate}

% ---------------------------------------------------------------------

\subsection{Verificação}

Para verificar se a compilação feita na seção \ref{sphinxCompile} ocorreu corretamente, recomenda-se fazer um teste de reconhecimento de voz contínuo com o binário \texttt{pocketsphinx\_continuous}, criado na compilação do \textit{Pocketsphinx}. Nesta verificação, o usuário fala uma palavra ou uma frase curta, em inglês, em seu microfone. Quando um silêncio é detectado, o programa analisa o \textit{utterance} obtido e imprime na tela o texto que calculou ser a melhor interpretação.

No diretório onde encontram-se as pastas \texttt{sphinxbase} e \texttt{pocketsphinx}, execute o conteúdo da listagem \ref{sphinxTest}:

\begin{lstlisting}[
  language=Bash,
  basicstyle=\scriptsize,
  caption={Comandos para teste de reconhecimento de voz contínuo usando \textit{Pocketsphinx}},
  label={sphinxTest}]
# Diretório contendo arquivos para reconhecimento de voz (modelos, etc.)
MODELDIR=pocketsphinx/model

./pocketsphinx/src/programs/pocketsphinx_continuous \
-inmic yes \                                 # Acionar uso do microfone
-hmm   $MODELDIR/en-us/en-us/mdef \          # Diretório do modelo acústico
-dict  $MODELDIR/en-us/cmudict-en-us.dict \  # Arquivo do dicionário
-lm    $MODELDIR/en-us/en-us.lm.bin          # Arquivo do modelo da língua
\end{lstlisting}

O programa imediatamente irá imprimir uma lista de seus parâmetros e seus respectivos valores. Depois, avisará ao usuário que está pronto para receber a entrada de voz por meio de uma linha terminada em \texttt{Ready....}

A listagem \ref{sphinx123} representa uma saída resumida ao se falar \texttt{``one two three''} no microfone. Os caracteres \texttt{[..]} representam uma ou mais linhas omitidas.

\begin{lstlisting}[
  basicstyle=\scriptsize,
  caption={Saída do \texttt{pocketsphinx\_continuous} ao se falar \texttt{``one two three''}},
  label={sphinx123}]
INFO: continuous.c(275): Ready....
INFO: continuous.c(261): Listening...
[..]
INFO: ngram_search_fwdtree.c(1550):     3081 words recognized (15/fr)
INFO: ngram_search_fwdtree.c(1552):   703838 senones evaluated (3400/fr)
INFO: ngram_search_fwdtree.c(1556):  2241048 channels searched (10826/fr)
[..]
INFO: ngram_search_fwdflat.c(302): Utterance vocabulary contains 154 words
INFO: ngram_search_fwdflat.c(948):     2575 words recognized (12/fr)
INFO: ngram_search_fwdflat.c(950):   148022 senones evaluated (715/fr)
INFO: ngram_search_fwdflat.c(952):   209298 channels searched (1011/fr)
[..]
INFO: ngram_search.c(1381): Lattice has 317 nodes, 942 links
INFO: ps_lattice.c(1380): Bestpath score: -4833
[..]
one two three
\end{lstlisting}
