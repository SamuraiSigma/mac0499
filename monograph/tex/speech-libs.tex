\chapter{Biblioteca para Reconhecimento de Voz}
\label{cap:speech-libs}

Neste capítulo, veremos o primeiro item necessário para atingirmos o objetivo final: uma biblioteca que fará o reconhecimento de voz dentro do módulo.

Uma implementação do zero fugiria do tema deste trabalho, pois seria necessário aprender sobre reconhecimento de padrões voltado a sons e outros tópicos relacionados a Inteligência Artificial. A outra opção existente, e a que seguiremos, é procurar por uma biblioteca existente e aprender a manejá-la.

Analisaremos quais as características necessárias e desejáveis na biblioteca ideal, e estudaremos a que melhor se adequa ao nosso objetivo dentre as opções existentes.

% ---------------------------------------------------------------------

\section{Considerações iniciais}

Recordemos os principais componentes para reconhecimento de voz, apresentados na seção \ref{sttComponents}. No contexto do módulo de reconhecimento de voz para \textit{Godot}, as seguintes associações surgem naturalmente:

\begin{itemize}
\item O \textbf{usuário} representa tipicamente o \textbf{jogador}, que interage parcialmente ou totalmente com o jogo por meio de comandos de voz.

\item O \textbf{dispositivo de STT} corresponde ao \textbf{módulo de reconhecimento de voz}, objetivo principal deste trabalho. Esta componente é usada pelo jogo para converter a fala do jogador em texto.

\item O \textbf{software de aplicação} é o \textbf{jogo} em si, feito em \textit{Godot}, que recebe indiretamente os comandos do usuário e realiza ações apropriadas.
\end{itemize}

% ---------------------------------------------------------------------

\section{A biblioteca ideal}

Realçamos novamente que o módulo de reconhecimento de voz será usado diretamente em jogos. Tal contexto automaticamente nos leva a pensar em diversas características que a biblioteca ideal deve possuir.

% ---------------------------------------------------------------------

\subsection{Características obrigatórias}

Em ordem decrescente de importância, temos:

\begin{enumerate}
\item \textbf{Ter código aberto e licença permissiva:} Justifica-se pela integração da biblioteca em uma \textit{game engine} de código aberto. A importância é ainda maior se levarmos em conta que jogos com fins comerciais podem ser produzidos em \textit{Godot}.

\item \textbf{Ser eficiente (rápida):} Já foi mencionado que o módulo de reconhecimento de voz será usado em uma \textit{game engine}. Um jogo é um \textit{software} onde tipicamente a eficiência é de extrema importância, pois costuma envolver a renderização de cenas várias vezes por segundo. Devido a isso, surge a necessidade da biblioteca ser \emph{rápida} para não afetar negativamente a experiência do jogador.

\item \textbf{Reconhecer inglês:} O inglês possui presença constante em cenários de computação. Portanto, é a única língua que a biblioteca deve obrigatoriamente oferecer suporte.

\item \textbf{Não ser pesada:} Não é desejável ter uma biblioteca que ocupe muito espaço em disco (o que poderia aumentar o tamanho do jogo que a utiliza) e memória (aspecto relacionado diretamente à eficiência).
\end{enumerate}

% ---------------------------------------------------------------------

\subsection{Características desejáveis}

Em ordem decrescente de importância, temos:

\begin{enumerate}
\item \textbf{Ser multiplataforma:} \textit{Godot} possibilita exportar jogos para diferentes plataformas, dentre elas Windows, MacOS, Unix, Android e iOS \citep{godotDeployPlatforms}. Uma biblioteca que possa ser compatível com o maior número possível destes sistemas operacionais tornaria o módulo de reconhecimento de voz mais flexível para a produção de jogos em diferentes ambientes.

\item \textbf{Reconhecer diferentes línguas:} Apesar da obrigatoriedade do inglês, a possibilidade de usar diferentes línguas aumentaria a versatilidade do módulo. Tal característica é acentuada ao notarmos que muitos jogos, hoje em dia, oferecem a possibilidade de alterar a língua.

\item \textbf{Ser implementada em C/C++:} Conforme veremos na seção \ref{cap:godot}, \textit{Godot} possui toda a sua base escrita em C++, linguagem também usada para a criação de módulos. A implementação da biblioteca na mesma linguagem ajudaria a simplificar problemas de compatibilidade. Eventualmente, C também é uma opção viável por ser aceita pela linguagem sucessora.
\end{enumerate}

% ---------------------------------------------------------------------

\section{Bibliotecas viáveis}

Após uma pesquisa, que pode ser resumida pelo artigo em \citep{speechRecog:16}, cinco bibliotecas de reconhecimento de voz em geral se destacam por seu uso:

\begin{itemize}
\item \emph{Kaldi} \citep{kaldi}: É a biblioteca mais recente da lista, com seu código publicado em 2011. Escrita em C++.

\item \emph{CMUSphinx} \citep{cmusphinx}: Desenvolvida pela \emph{Carnegie Mellon University}, possui diversos pacotes para diferentes tarefas e aplicações. O pacote principal é escrito em Java. Existe também a variante \emph{Pocketsphinx}, com características interessantes para este trabalho: é escrita em C, possuindo maior velocidade e portabilidade que a biblioteca original.

\item \emph{HTK} \citep{htk}: Desenvolvida pela \emph{Cambridge University Engineering Department}, HTK é uma sigla para \emph{Hidden Markov Model Toolkit}. É escrita em C, com novas versões sendo lançadas consistentemente.

\item \emph{Simon} \citep{Simon}: Popular para Linux e escrita em C++, Simon utiliza \emph{CMUSphinx}, \emph{HTK} e \emph{Julius} internamente. Não havia suporte para \emph{MacOS} até 3 de abril de 2017.

\item \emph{Julius} \citep{Julius}: Desenvolvida pela \emph{Interactive Speech Technology Consortium} e escrita em C. Infelizmente, o suporte para inglês é limitado e não pode ser usado para propósitos comerciais, o que nos força a descartar esta biblioteca como uma possível opção.
\end{itemize}

Das cinco bibliotecas descritas, as mais viáveis são as três primeiras (\emph{Kaldi}, \emph{CMUSphinx} e \emph{HTK}). \emph{Simon} está em seus primeiros passos para MacOS, por isso a relutância em seu uso.

Um artigo de 2014 comparou \emph{Kaldi}, \emph{CMUSphinx} e \emph{HTK} em relação a precisão e tempo gasto \citep{compareSpeech}. \emph{Kaldi} obteve resultados vastamente superiores; \emph{CMUSphinx} obteve bons resultados em pouco tempo; \emph{HTK} precisou de muito mais tempo e treino para conseguir resultados na ordem dos outros dois.

No restante deste capítulo, analisaremos com mais cuidado as bibliotecas \emph{Kaldi}, \emph{PocketSphinx} e \emph{HTK}, com o intuito de acompanhar mais de perto suas funcionalidades, vantagens e desvantagens.

O sistema operacional utilizado foi \texttt{ubuntu 16.04 LTS, 64 bits}.

% ---------------------------------------------------------------------

\section{\emph{Pocketsphinx}}

\subsection{Instalação}

Os passos abaixo foram baseados nas instruções em \citep{pocketsphinxInstall}. Supõe-se que o usuário esteja usando um sistema \emph{Unix}, com acesso a privilégios administrativos (\emph{root}).

Antes de começar, é necessário instalar as seguintes dependências: \texttt{gcc, automake, autoconf, libtool, bison, swig, python-dev, pulseaudio}. Se estiver usando um sistema como \emph{Ubuntu}, por exemplo, digite no terminal:
\shellcmd{sudo apt-get install gcc automake autoconf libtool bison \textbackslash \linebreak \hphantom{4} swig python-dev pulseaudio}

Primeiramente, baixaremos e instalaremos o pacote \emph{Sphinxbase}, que oferece funcionalidades comuns a todos os projetos \emph{CMUSphinx}:

\begin{enumerate}
\item Clone o repositório do \emph{Sphinxbase}, o que resultará no diretório \texttt{sphinxbase}:
\shellcmd{git clone https://github.com/cmusphinx/sphinxbase}

\item Dentro do diretório \texttt{sphinxbase}, execute o \emph{script} \texttt{autogen.sh} para gerar o arquivo \texttt{configure}:
\shellcmd{./autogen.sh}

\item Execute o \emph{script} \texttt{configure} que foi criado no último passo:
\shellcmd{./configure}

Se a plataforma utilizada não possui aritmética de ponto flutuante, deve-se rodar ao invés disso:
\shellcmd{./configure ---enable-fixed ---without-lapack}

Note que qualquer dependência ausente no sistema (por exemplo, o pacote \emph{swig}) será notificada ao usuário neste passo. Se a execução ocorrer sem problemas, um \texttt{Makefile} será gerado.

\item Construa a biblioteca através do \texttt{Makefile}:
\shellcmd{make}

\item Instale a biblioteca \emph{Sphinxbase} no sistema:
\shellcmd{sudo make install}

\emph{Observação:} Para desinstalar a biblioteca \emph{Sphinxbase} do sistema, basta digitar:
\shellcmd{sudo make uninstall}
\end{enumerate}

Os passos necessários para baixar e instalar a biblioteca \emph{Pocketsphinx} são semelhantes:

\begin{enumerate}
\item Clone o repositório do \emph{Pocketsphinx}, o que resultará no diretório \texttt{pocketsphinx}:
\shellcmd{git clone https://github.com/cmusphinx/pocketsphinx}

\item Certifique-se que os diretórios \texttt{sphinxbase} e \texttt{pocketsphinx} estejam no mesmo diretório.

\item Dentro do diretório \texttt{pocketsphinx}, execute o \emph{script} \texttt{autogen.sh} para gerar o arquivo \texttt{configure}:
\shellcmd{./autogen.sh}

\item Execute o \emph{script} \texttt{configure} que foi criado no último passo:
\shellcmd{./configure}

Note que qualquer dependência ausente no sistema será notificada ao usuário neste passo. Se a execução ocorrer sem problemas, um \texttt{Makefile} será gerado.

\item Construa a biblioteca através do \texttt{Makefile}:
\shellcmd{make}

\item Instale a biblioteca \emph{Pocketsphinx} no sistema:
\shellcmd{sudo make install}

\emph{Observação:} Para desinstalar a biblioteca \emph{Pocketsphinx} do sistema, basta digitar:
\shellcmd{sudo make uninstall}
\end{enumerate}
