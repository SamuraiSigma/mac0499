\chapter{Módulo \textit{Speech to Text} para \textit{Godot}}
\label{cap:stt-module}

Após adquirirmos conhecimento sobre a biblioteca \textit{Pocketsphinx} e a \textit{game engine} \textit{Godot}, chegou o momento de construirmos o módulo de reconhecimento de voz.

Conforme descrito na seção \ref{godotLanguages}, a linguagem \mbox{\textit{GDScript}} é extremamente prática para programar estruturas em um jogo feito em \textit{Godot}. No entanto, às vezes deseja-se otimizar alguma parte crítica através de \textit{C++} ou adicionar uma nova funcionalidade inexistente em \textit{Godot}. Os módulos servem justamente para este objetivo, pois não fazem parte do código essencial da \textit{game engine}.

Este capítulo documenta os passos e decisões de projeto tomados na criação do módulo, a qual chamaremos de \textit{Speech to Text}. Pressupomos que o leitor esteja familiarizado com as instruções para compilação de \textit{Godot}, vistas na seção \ref{godotCompile}, e com a biblioteca \textit{Pocketsphinx} (capítulo \ref{cap:pocketsphinx}), que será usada para a realização do reconhecimento de voz.

As instruções para criação do módulo foram baseadas no tutorial existente na documentação de \textit{Godot} \citep{godotModuleCreation}.

Todas as instruções e comandos apresentados foram originalmente realizados no sistema \texttt{Ubuntu 16.04 LTS, 64-bit} do autor.

% ---------------------------------------------------------------------

\section{Primeiros passos}

Antes de começarmos a implementar o módulo em si, precisaremos tomar algumas medidas simples de preparação.

\subsection{Criação do diretório do módulo}

Todos os módulos ativos são encontrados como subdiretórios dentro da pasta \texttt{modules/} no código fonte. Começaremos, portanto, com a criação do diretório \texttt{speech\_to\_text}:

\begin{lstlisting}[language=Bash]
$ cd modules
$ mkdir speech_to_text
$ cd speech_to_text
\end{lstlisting}

% ---------------------------------------------------------------------

\subsection{Adição do pacote \textit{Sphinxbase}}

Usaremos a biblioteca \textit{Pocketsphinx} para realizar o reconhecimento de voz no módulo. Um dos requisitos necessários para seu funcionamento, conforme visto na seção \ref{sphinxCompile}, é o pacote \textit{Sphinxbase}. A seguir, apresentamos instruções para inserir os arquivos essenciais deste pacote no diretório do módulo.

\begin{enumerate}
\item Baixe o pacote \textit{Sphinxbase} em sua versão atual mais estável, a \textbf{5-prealpha}.

\begin{lstlisting}
$ SPHINXURL="https://sourceforge.net/projects/cmusphinx/files"
$ wget $SPHINXURL/sphinxbase/5prealpha/sphinxbase-5prealpha.tar.gz
\end{lstlisting}

\item Extraia e renomeie o pacote baixado.

\begin{lstlisting}
$ tar -xvf sphinxbase-5prealpha
$ mv sphinxbase-5prealpha sphinxbase
\end{lstlisting}

\item Remova arquivos supérfluos, como \texttt{Makefiles}, arquivos de teste e \textit{scripts} de compilação. Estes serviriam para aumentar, desnecessariamente, o tamanho do módulo. Em outras palavras, somente as interfaces e implementações nos pacotes serão mantidas. Veja a listagem \ref{sphinxbaseEssential} para maiores detalhes.

\lstinputlisting[
  language=Bash,
  caption={Remoção de arquivos supérfluos no pacote \textit{Sphinxbase}},
  label={sphinxbaseEssential}]
  {listing/sphinxbase-essential.sh}
\end{enumerate}

% ---------------------------------------------------------------------

\subsection{Adição do pacote \textit{Pocketsphinx}}

Precisamos, também, do pacote \textit{Pocketsphinx} para a biblioteca homônima funcionar. A seguir, apresentamos instruções para inserir os arquivos essenciais deste pacote no diretório do módulo.

\begin{enumerate}
\item Baixe o pacote \textit{Pocketsphinx} em sua versão atual mais estável, a \textbf{5-prealpha}.

\begin{lstlisting}
$ SPHINXURL="https://sourceforge.net/projects/cmusphinx/files"
$ wget $SPHINXURL/pocketsphinx/5prealpha/pocketsphinx-5prealpha.tar.gz
\end{lstlisting}

\item Extraia e renomeie o pacote baixado.

\begin{lstlisting}
$ tar -xvf pocketsphinx-5prealpha
$ mv pocketsphinx-5prealpha pocketsphinx
\end{lstlisting}

\item Remova arquivos supérfluos, isto é, que não sejam interfaces ou implementações. Veja a listagem \ref{pocketsphinxEssential} para maiores detalhes.

\lstinputlisting[
  language=Bash,
  caption={Remoção de arquivos supérfluos no pacote \textit{Pocketsphinx}},
  label={pocketsphinxEssential}]
  {listing/pocketsphinx-essential.sh}
\end{enumerate}

% ---------------------------------------------------------------------

\section{Planejamento}

Quais os requisitos funcionais e não funcionais que queremos atender? O que um típico usuário do módulo \textit{Speech to Text} desejaria para poder usar em seu jogo? Todo projeto deve começar com algum planejamento mínimo de onde se quer chegar para obter algum sucesso.

% ---------------------------------------------------------------------

\subsection{Requisitos não funcionais}

% TODO: Fix references

Reconhecimento de voz em jogos geralmente é usado em um contexto de tempo real. Isto é, para uma dada fala do usuário, não desejamos que o jogo demore muito para dar alguma forma de resposta com o risco de comprometer seu aspecto lúdico. A preocupação é reduzida ao lembrarmos que \textit{Pocketsphinx} apresentou resultados rápidos nos testes realizados na seção \ref{???}.

Portanto, em termos dos principais parâmetros de reconhecimento de voz definidos na seção \ref{sttMainTerms}, projetaremos o módulo com a questão de \textbf{eficiência} em mente:

\begin{itemize}
\item \textbf{Fluência}: Idealmente, a forma de comunicação poderia chegar até \emph{palavras conectadas}. Uma \textit{fala contínua} demandaria um processamento muito pesado e comprometedor para o jogo.

\item \textbf{Dependência do usuário}: Um sistema \emph{independente} é mais flexível por atender a uma maior quantidade de pessoas sem a necessidade de um longo treinamento antes de começaram a jogar.

\item \textbf{Vocabulário}: Deve ser tipicamente \emph{pequeno} (não mais do que 40 palavras). Um vocabulário muito grande aumentaria a velocidade de reconhecimento, que por sua vez afetaria a experiência do jogador.

\item \textbf{Parâmetros ambientais}: Não é esperado que interfiram tanto no jogo. A relação sinal/ruído deve ser baixa, pois um ambiente muito barulhento comprometeria a jogabilidade. Por fim, desejamos que o usuário possa falar em um tom de voz normal, sem precisar ``forçar'' a pronúncia das palavras ou aumentar sem tom para o reconhecimento ser possível. Tais características são automaticamente tratadas pelo modelo acústico usado no \textit{Pocketsphinx}.
\end{itemize}

Desejamos que o módulo seja \textbf{confiável} em relação à acurácia do reconhecimento de voz. Conforme vimos na seção \ref{???}, isto dependerá dos modelos usados na configuração do \textit{Pocketsphinx}.

\textbf{Configurabilidade} também é uma característica desejada: o usuário do módulo deverá ter controle sobre a língua do reconhecimento e o vocabulário reconhecido, por exemplo. \textit{Pocketsphinx} permite isso facilmente com a alteração de seus arquivos de configuração, incluindo o modelo acústico e as palavras-chave.

O módulo deverá ser de \textbf{propósito geral} em relação ao tipo de jogo em que é empregado (ação, terror, plataforma, etc.); portanto, não é possível prever características do típico usuário do jogo. Este requisito, em geral, não é tão preocupante quando levamos em conta o uso de um modelo acústico geral com a biblioteca \textit{Pocketsphinx}.

É importante que o módulo seja \textbf{tolerante a erros}, isto é, que comunique ao restante do sistema quando um problema ocorre dentro de si.

Por fim, um requisito desejável, mas a princípio não estritamente necessário, é a  \textbf{portabilidade}. Apesar das classes internas de \textit{Godot} e a biblioteca \textit{Pocketsphinx} terem sido projetados para funcionarem em diversos sistemas operacionais, colocaremos plataformas \textit{Unix} como a meta principal. Suporte a outras plataformas poderá ser feito depois, dependendo da complexidade da implementação.

% ---------------------------------------------------------------------

\subsection{Requisitos funcionais}
\label{moduleFunctionalRequirements}

A princípio, desejamos que o reconhecimento de voz seja executado em paralelo com o restante do jogo. Isto é, gostaríamos que a execução não parasse totalmente até obter um comando por voz do usuário. Queremos, também, uma forma de verificar se o reconhecimento está ativo e de iniciá-lo/desligá-lo a qualquer momento.

As palavras reconhecidas pelo módulo \textit{Speech to Text} não precisariam ser interpretadas imediatamente pelo jogo. Uma ideia mais flexível é guardá-las em um \textit{buffer} e deixar o próprio jogo lê-las em seu ritmo.

% TODO: Update reference on Pocketsphinx keywords section below

Como o vocabulário deve ser tipicamente pequeno, o reconhecimento por \emph{palavras-chaves} do \textit{Pocketsphinx} é bem mais viável do que por modelo de língua.

A configurabilidade desejada nos requisitos não funcionais nos leva a precisar de uma interface para ajustar parâmetros e arquivos do reconhecimento de voz. Em particular, um usuário estaria interessado em configurar o modelo acústico, o dicionário e as palavras-chave.

% ---------------------------------------------------------------------

\section{Implementação}

Apresentamos, na figura \ref{sttModuleClassDiagram}, um diagrama de classes do módulo \textit{Speech to Text}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{image/stt-module.pdf}
  \caption{Diagrama de classes do módulo \textit{Speech to text}}
  \label{sttModuleClassDiagram}
\end{figure}

Omitimos alguns métodos privados e os construtores/destrutores para simplificar o diagrama. \textit{Godot}, inclusive, não permite que construtores e destrutores possuam argumentos como uma forma de padronizar o instanciamento e liberação de objetos.

Os tipos \texttt{String} e \texttt{Vector} usados não são os da STL (\textit{Standard Template Library}) de \textit{C++}, mas sim implementações próprias de \textit{Godot} para essas estruturas.

Quase todas as classes implementadas, exceto \textit{FileDirUtil}, possuem um método \texttt{\_bind\_methods()}. Este método, padronizado em classes da \textit{game engine}, é usado para ligar nomes a constantes ou referências de métodos, permitindo seu uso em \mbox{\textit{GDScript}}; todas as ligações são guardadas numa grande classe \textit{singleton} denominada \textit{ObjectTypeDB}. A listagem \ref{configBindMethods} exemplifica a adição de uma linha no método \texttt{\_bind\_methods()} de \textit{STTConfig} para ser possível usar o método \texttt{init()} desta mesma classe em \mbox{\textit{GDScript}}.

\begin{lstlisting}[
  language=C++,
  label=configBindMethods,
  caption={Adicionando o método \texttt{init()} de \textit{STTConfig} para uso em \mbox{\textit{GDScript}}}
]
void STTConfig::_bind_methods() {
    ObjectTypeDB::bind_method("init", &STTConfig::init);
}
\end{lstlisting}

A seguir, detalharemos cada classe presente na figura \ref{sttModuleClassDiagram}.

% ---------------------------------------------------------------------

\subsection{Classe \textit{STTConfig}}

Como o nome sugere, \textit{STTConfig} é uma classe de configuração para a realização do reconhecimento de voz. Por possuir a característica de servir mais como um armazenamento de informação, decidimos fazer a classe herdar de \textit{Resource} (visto na seção \ref{godotResource}).

\textit{STTConfig} possui duas funcionalidades principais:

\subsubsection{Definir arquivos de configuração}

Nomes de arquivos de configuração são tratados pelos \textit{getters} e \textit{setters} de \texttt{hmm\_dirname}, \texttt{dict\_filename} e \texttt{kws\_filename}, que correspondem, respectivamente, ao diretório do modelo acústico, o arquivo de dicionário e o arquivo de palavras-chaves.

Verifica-se se os nomes passados como argumentos para os \textit{setters} correspondem a arquivos/diretórios existentes. No entanto, infelizmente não há como checar facilmente, em tempo de execução, se o arquivo/diretório possui erros de sintaxe. O diretório do modelo acústico, por exemplo, contém arquivos binários que, a princípio, parecem impossíveis de serem verificados. Optamos, portanto, pela filosofia de ``atirar primeiro, perguntar depois'' ao avisar posteriormente que houve problemas no uso dos arquivos.

Por fim, resta um problema para tratarmos, resultante da distinção entre os sistemas de arquivo de \textit{Godot} (visto na seção \ref{godotFileSystem}) e \textit{Pocketsphinx}. Suponha que o desenvolvedor de um jogo tenha guardado seu arquivo de dicionário, o \texttt{dicionario.dict}, na raiz do projeto. Como referenciar este arquivo? \textit{Godot} utilizaria o caminho \texttt{res://dicionario.dict}, mas \textit{Pocketsphinx} não entende este prefixo, necessitando do caminho absoluto usado no sistema.

Uma solução simples seria converter o caminho com \texttt{res://} para o caminho absoluto do sistema operacional; o método \texttt{???} da classe \textit{???} de \textit{Godot} faz justamente isso. No entanto, se o jogo estiver no formato de um binário fechado, é impossível referenciar qualquer arquivo dentro dele por meio da plataforma hospedeira.

A solução final implementada envolve usar o outro prefixo definido pela \textit{game engine}, o \textbf{\texttt{user://}}. Copiam-se todos os arquivos e diretórios de configuração para este caminho e usa-se o método \texttt{get\_data\_dir()} da classe \textit{OS} para buscar seu equivalente na plataforma hospedeira. Por precaução, adotou-se a prática de sobrescrever arquivos e diretórios copiados previamente.

\subsubsection{Inicializar variáveis do \textit{Pocketsphinx}}

A inicialização de varíaveis usadas por \textit{Pocketsphinx} é feita através de \texttt{init()}. Os nomes do diretório do modelo acústico, do arquivo de dicionário e do arquivo de palavras-chave precisam ter sido definidos previamente com os apropriados \textit{setters}, ou o método retornará um número de erro.

Deparamo-nos com outro problema de compatibilidade: os nomes dos arquivos são fornecidos com o tipo \texttt{String} adotado por \textit{Godot}. No entanto, \textit{Pocketsphinx} não conhece este tipo, utilizando o \texttt{char *} comumente encontrado em \textit{C} para receber estes mesmos nomes. Felizmente, \texttt{String} possui um método \texttt{c\_str()} para realizar a conversão.

% TODO: Fix reference below

O método \texttt{init()} irá inicializar as variáveis de configuração \texttt{cmd\_ln\_t}, de gravação de voz \texttt{ad\_rec\_t} e o decodificador \texttt{ps\_decoder\_t} (todos vistos na seção \ref{???}). Caso algum problema ocorra, retorna-se um número de erro, pertencente à classe \mbox{\textit{STTError}}, relativo ao problema ocorrido.

A cópia de arquivos para o caminho \textit{user://}, mencionada anteriormente, também ocorre neste método.

% ---------------------------------------------------------------------

\subsection{Classe \textit{STTRunner}}

% ---------------------------------------------------------------------

\subsection{Classe \textit{STTQueue}}

% ---------------------------------------------------------------------

\subsection{Classe \textit{STTError}}

% ---------------------------------------------------------------------

\subsection{Classe \textit{FileDirUtil}}

% ---------------------------------------------------------------------

\section{Divulgação}

Todo o código fonte do módulo \textit{Speech to Text} encontra-se em um repositório no GitHub do autor \citep{sttModuleGitHub}. Também foram disponibilizados binários dos editores \textit{Godot} e \textit{templates de exportação}, ambos compilados previamente com o módulo \citep{sttModuleDownload}.

% TODO: Recomendar baixar e compilar Godot com o módulo

\textit{Speech to Text} foi divulgado em dois fóruns de \textit{Godot}, onde obteve algumas poucas aprovações:

\begin{itemize}
\item \textbf{Godot Engine Q\&A} \citep{sttModuleGodotQA}: O site oficial de \textit{Godot} disponibiliza uma seção para perguntas e respostas, onde existe uma subseção para publicação de projetos.

\item \textbf{Godot Developers} \citep{sttModuleGodotDevelopers}: Embora seja mais voltado para jogos produzidos na \textit{game engine}, este fórum possui uma seção para compartilhamento de recursos e ferramentas.
\end{itemize}
