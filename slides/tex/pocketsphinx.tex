\begin{frame}{\textit{Pocketsphinx}}{Funcionamento}

\begin{itemize}
\item Desenvolvida pela \textit{Carnegie Mellon University} (projeto \textit{CMUSphinx})

\item Define que palavras são formadas por \textbf{fonemas}

\item<2-> Voz $\rightarrow$ \textit{Utterances} $\rightarrow$ Vetores de características

\item<3-> Utiliza o \textbf{Modelo Oculto de Markov} na interpretação

\begin{itemize}
  \item Trata a fala gravada como uma sequência de estados, que transitam entre si com certa \textbf{probabilidade}
\end{itemize}
\end{itemize}

\uncover<4->{
\begin{center}
\textbf{Estados mais prováveis $\rightarrow$ Melhor interpretação da voz}
\end{center}
}

\end{frame}

% ---------------------------------------------------------------------

\begin{frame}{\textit{Pocketsphinx}}{Arquivos de configuração}

\begin{itemize}
\item \textbf{Modelo acústico}: Arquivos que configuram detectores de fonemas

\item<2-> \textbf{Dicionário fonético}: Mapeamento \{palavras \(\rightarrow\) fonemas\}
\end{itemize}

\uncover<2->{
\begin{center}
  \color{Maroon}\texttt{yellow Y EH L OW}
\end{center}
}

\begin{itemize}
\item<3-> \textbf{Palavras-chave}: Palavras a serem detectadas, de acordo com limiar
\end{itemize}

\uncover<3->{
\begin{center}
  \color{Maroon}\texttt{yellow /1e-6/}
\end{center}
}
\end{frame}

% ---------------------------------------------------------------------

\begin{frame}{\textit{Pocketsphinx}}{Implementação do reconhecimento de voz}

\begin{algorithmic}[1]
\footnotesize

\Function{\textbf{recognize\_speech}($recorder$, $decoder$)}{}
\State {\color{Maroon}\Comment{$recorder$: Tipo usado para gravar voz
  \hphantom{\hspace{17em}}}}
\State {\color{Maroon}\Comment{$decoder$: Tipo usado para decodificar áudio
  \hphantom{\hspace{14.25em}}}}

\uncover<2->{
\State{int $buffer[SIZE]$, $bytes$}
\State{bool $utt\_started$}
}

\uncover<3->{
\vspace{0.4em}
\State{start\_recording($recorder$)}
\State{start\_utterance($decoder$)}
}

\uncover<4->{
\vspace{0.4em}
\While{$\mathbf{true}$}
  \State{$bytes$ $\leftarrow$ read\_voice($recorder$, $buffer$, $SIZE$)}
  \State{process\_raw($decoder$, $buffer$, $bytes$)}
}

\uncover<5->{
\vspace{0.4em}
  \If{in\_speech($decoder$) \textbf{and} \textbf{not} $utt\_started$}
    {\color{Maroon}\Comment{Usuário começou a falar}}
    \State{$utt\_started \leftarrow true$}
  \EndIf
}

\uncover<6->{
  \If{\textbf{not} in\_speech($decoder$) \textbf{and} $utt\_started$}
    {\color{Maroon}\Comment{Usuário parou de falar
    \hphantom{\hspace{0.5em}}}}
    \State{end\_utterance($decoder$)}
    \State{get\_hypothesis($decoder$)}
}

\uncover<7->{
    \State{start\_utt($decoder$)}
    \State{$utt\_started \leftarrow false$}
  \EndIf
\EndWhile

\EndFunction
}
\end{algorithmic}

\end{frame}
